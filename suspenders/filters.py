import logging
import typing

from .pyes_filters import ESRange, ESRangeOp
from .queries import BoolQuery

logger = logging.getLogger("suspenders")


class Filter:
    # If name is an int
    # then by convention it was generated by a hash
    # and really isn't comparable across instances
    # BoolFilters are an example of where this is used.
    name: typing.Union[str, int]

    # If true, this filter potentially applies to multiple keys
    # or potentially applies to multiple values in the same key
    # as such we do not use FilterDict warnings for duplicate filters here
    is_multi = False

    def __init__(self, **kwargs):
        """
        fields: if is [], the _source is not returned
        """
        self.name = kwargs.get("name", None) or kwargs.get("field", None) or hash(self)

    def merge(self, value: "Filter"):
        """Merge two filters of the same type"""
        return None

    def to_dict(self):
        """Compatability with elasticsearch-dsl"""
        return self.serialize()

    def serialize(self):
        """Serialize without making it into a filter"""
        raise NotImplementedError


class RangeFilter(Filter):
    def __init__(self, field, qrange=None, **kwargs):
        super().__init__(field=field, **kwargs)

        self.field = field
        self.ranges = []
        if qrange:
            self.add(qrange)

    def add(self, qrange):
        if isinstance(qrange, list):
            self.ranges.extend(qrange)
        elif isinstance(qrange, ESRange):
            self.ranges.append(qrange)

    def serialize(self):
        if not self.ranges:
            raise RuntimeError("A least a range must be declared")

        filters = {}
        for r in self.ranges:
            filters.update(r.serialize()[1])

        return {"range": {self.field: filters}}


class TermFilter(Filter):
    _internal_name = "term"

    def __init__(self, field=None, value=None, **kwargs):
        super().__init__(field=field, **kwargs)
        self._values = {}

        if field is not None and value is not None:
            self.add(field, value)

    def add(self, field, value):
        self._values[field] = value

    def serialize(self):
        if not self._values:
            raise RuntimeError(f"TermsFilter must have at least a field/value pair to be serialized.")
        return {self._internal_name: self._values}


class TermsFilter(Filter):
    _internal_name = "terms"
    is_multi = True

    def __init__(self, field=None, values=None, **kwargs):
        super().__init__(field=field, **kwargs)
        self.__field = field
        self.__values = set([str(v) for v in values])

        if not self.__field:
            raise ValueError("TermsFilter must be initialized with a field")

    def merge(self, value: "TermsFilter"):
        """Merge two terms filters"""
        if value.name == self.name:
            values = self.values().union(value.values())
            return TermsFilter(field=self.name, values=values)

    def values(self) -> typing.Set:
        return set(self.__values)

    def serialize(self):
        return {self._internal_name: {self.__field: self.__values}}


def parse_kwargs(kwargs):
    """
    Parse a single kwarg into a key, value tuple.
    Also returns the value at the options kwarg if present as the third item in the tuple.
    """
    arguments = kwargs.copy()

    # Get Options
    if "options" in arguments:
        options = arguments["options"]
        del arguments["options"]
    else:
        options = {}

    # Get Key/Value
    try:
        key, value = list(arguments.items())[0]
    except LookupError:
        raise ValueError("Term key=value pair not present")

    return key, value, options


def parse_filter(**kwargs) -> typing.Union[TermsFilter, RangeFilter, TermFilter]:
    """
    Parse the passed parameters and return a query type that matches that signature

    E.g.

    Greater than => blah__gt
    """

    key, value, options = parse_kwargs(kwargs)

    parts = key.split("__")

    # Handle Filter DSL
    op = parts[-1]
    field = ".".join(parts[0:-1])

    if op == "in":
        a_filter = TermsFilter(field=field, values=value)
    elif op == "not_in":
        logger.warning("not_in is not supported as a filter anymore")
    elif op == "between" or op == "range":
        # Acts as inclusive
        # Notes: You can only take the range of strings or integer values. Not floats.
        # (but you can take an integer range of a float field )
        a_filter = RangeFilter(
            field,
            [
                ESRangeOp(field=field, op1="gte", value1=value[0]),
                ESRangeOp(field=field, op1="lte", value1=value[1]),
            ],
        )

    elif op in ["gt", "gte", "lt", "lte"]:
        a_filter = RangeFilter(field, ESRangeOp(field=field, op1=op, value1=value))
    else:
        field = ".".join(parts)
        a_filter = TermFilter(field=field, value=value, **options)

    return a_filter


class BoolFilter(BoolQuery, Filter):
    is_multi = True

    # todo: BoolFilter should check that it's must/must_not/optional paramers are all filters
    def serialize(self):
        """Serialize without making it into a filter"""
        raise self.to_dict()
